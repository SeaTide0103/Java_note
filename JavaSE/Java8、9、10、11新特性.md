### Java 8新特性

#### Lambda表达式

-  Lambda表达式的使用举例

~~~java
@Test
public void test1() {
    Runnable r1 = new Runnable() {
        @Override
        public void run() {
            System.out.println("我爱Java");
        }
    };
    r1.run();

    System.out.println("*********************************");

    // Lambda表达式的写法
    Runnable r2 = () -> System.out.println("我爱PHP");
    r2.run();
}

@Test
public void test2() {
    Comparator<Integer> com1 = new Comparator<>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return Integer.compare(o1, o2);
        }
    };

    int compare = com1.compare(21, 12);
    System.out.println(compare);

    System.out.println("*********************************");

    // Lambda表达式的写法
    Comparator<Integer> com2 = (o1, o2) -> Integer.compare(o1, o2);
    int compare2 = com2.compare(12, 21);
    System.out.println(compare2);

    System.out.println("*********************************");

    // 方法引用
    Comparator<Integer> com3 = Integer :: compare;
    int compare3 = com3.compare(13, 13);
    System.out.println(compare3);
}
~~~

- Lambda表达式的使用

~~~java
package com.test.java1;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.function.Consumer;

/**
 * Lambda表达式的使用
 *
 * 1、举例：(o1, o2) -> Integer.compare(o1, o2);
 *
 * 2、格式：
 *      “->” 该操作符被称为 Lambda 操作符 或 箭头操作符
 *      左侧：Lambda形参列表 （其实就是接口中的抽象方法的形参列表）
 *      右侧：Lambda 体，是抽象方法的实现逻辑，也即Lambda 表达式要执行的功能。（其实就是重写的抽象方法的方法体）
 *
 * 3、Lambda表达式的使用：（分6种情况介绍）
 *      总结：
 *      ->左边：Lambda形参列表的参数类型可以省略(类型推断)；如果Lambda形参列表只有一个参数，其一对()也可以省略
 *      ->右边：Lambda体应该使用一对{}包裹；如果Lambda体只有一条执行语句(可能是return语句)，可以省略这一对{}和return关键字
 *
 * 4、Lambda表达式的本质：作为函数式接口的实例
 */
public class LambdaTest1 {

    // 语法格式一：无参，无返回值
    @Test
    public void test1() {
        Runnable r1 = new Runnable() {
            @Override
            public void run() {
                System.out.println("我爱Java");
            }
        };
        r1.run();

        System.out.println("*********************************");

        // Lambda表达式的写法
        Runnable r2 = () -> {
            System.out.println("我爱PHP");
        };
        r2.run();
    }

    // 语法格式二：Lambda 需要一个参数，但是没有返回值。
    @Test
    public void test2() {
        Consumer<String> consumer = new Consumer<>() {
            @Override
            public void accept(String s) {
                System.out.println(s);
            }
        };
        consumer.accept("我爱北京天安门");

        System.out.println("*********************************");

        Consumer<String> consumer1 = (String s) -> {
            System.out.println(s);
        };
        consumer1.accept("我爱打游戏");
    }

    // 语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”
    @Test
    public void test3() {
        Consumer<String> consumer1 = (String s) -> {
            System.out.println(s);
        };
        consumer1.accept("abcdefg");

        System.out.println("*********************************");

        Consumer<String> consumer2 = (s) -> {
            System.out.println(s);
        };
        consumer2.accept("abcdefg123");

        // 其他类型推断举例
        ArrayList<String> list = new ArrayList<>(); // 类型推断
        int[] arr = {1,2,3};// 类型推断
    }

    // 语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略
    @Test
    public void test4() {
        Consumer<String> consumer1 = (s) -> {
            System.out.println(s);
        };
        consumer1.accept("abcdefg");

        System.out.println("*********************************");

        Consumer<String> consumer2 = s -> {
            System.out.println(s);
        };
        consumer2.accept("abcdefg123");
    }

    // 语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值
    @Test
    public void test5() {
        Comparator<Integer> comparator = new Comparator<>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                System.out.println(o1);
                System.out.println(o2);
                return o1.compareTo(o2);
            }
        };
        System.out.println(comparator.compare(12, 21));

        System.out.println("*********************************");

        Comparator<Integer> comparator1 = (o1, o2) -> {
            System.out.println(o1);
            System.out.println(o2);
            return o1.compareTo(o2);
        };
        System.out.println(comparator1.compare(21, 12));

    }

    // 语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略
    @Test
    public void test6() {
        Comparator<Integer> comparator1 = (o1, o2) -> {
            return o1.compareTo(o2);
        };
        System.out.println(comparator1.compare(21, 12));

        System.out.println("*********************************");

        Comparator<Integer> comparator2 = (o1, o2) -> o1.compareTo(o2);
        System.out.println(comparator2.compare(12, 21));
    }
}
~~~

#### 函数式(Functional)接口

- 定义

  > 只包含一个抽象方法的接口，称为函数式接口。
  >
  > 我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。
  >
  > 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。

- Java内置四大核心函数式接口介绍及使用举例

~~~java
package com.test.java1;

import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * Java内置的4大核心函数式接口
 *
 * 消费型接口： Consumer<T>   void accept(T t)
 * 供给型接口： Supplier<T>   T get()
 * 函数型接口： Function<T,R> R apply(T t)
 * 断定型接口： Predicate<T>  boolean test(T t)
 *
 */
public class LambdaTest2 {

    // Consumer举例
    @Test
    public void test1() {
        happyTime(500, new Consumer<Double>() {
            @Override
            public void accept(Double aDouble) {
                System.out.println("买了一本书，价格为：" + aDouble);
            }
        });

        System.out.println("******************************");

        // Lambda表达式
        happyTime(1000, money -> System.out.println("买个电脑，价格为：" + money));

    }

    public void happyTime(double money, Consumer<Double> con) {
        con.accept(money);
    }

    @Test
    public void test2() {
        List<String> list = Arrays.asList("北京", "天津", "南京");
        List<String> stringList = filterString(list, new Predicate<String>() {
            @Override
            public boolean test(String s) {
                return s.contains("京");
            }
        });
        System.out.println(stringList);

        System.out.println("******************************");

        // Lambda表达式
        List<String> stringList1 = filterString(list, s -> s.contains("京"));
        System.out.println(stringList1);
    }

    // 根据给定的规则，过滤集合中的字符串。此规则由Predicate的方法决定
    public List<String> filterString(List<String> list, Predicate<String> predicate) {
        ArrayList<String> filterList = new ArrayList<>();

        for (String s : list) {
            if (predicate.test(s)) {
                filterList.add(s);
            }
        }

        return  filterList;
    }
}
~~~

#### 方法引用与构造器引用

- Employee类

~~~java
package com.test.java2;

public class Employee {

	private int id;
	private String name;
	private int age;
	private double salary;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public double getSalary() {
		return salary;
	}

	public void setSalary(double salary) {
		this.salary = salary;
	}

	public Employee() {

	}

	public Employee(int id) {

		this.id = id;
	}

	public Employee(int id, String name) {
		this.id = id;
		this.name = name;
	}

	public Employee(int id, String name, int age, double salary) {

		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}

	@Override
	public String toString() {
		return "Employee{" + "id=" + id + ", name='" + name + '\'' + ", age=" + age + ", salary=" + salary + '}';
	}

	@Override
	public boolean equals(Object o) {
		if (this == o)
			return true;
		if (o == null || getClass() != o.getClass())
			return false;

		Employee employee = (Employee) o;

		if (id != employee.id)
			return false;
		if (age != employee.age)
			return false;
		if (Double.compare(employee.salary, salary) != 0)
			return false;
		return name != null ? name.equals(employee.name) : employee.name == null;
	}

	@Override
	public int hashCode() {
		int result;
		long temp;
		result = id;
		result = 31 * result + (name != null ? name.hashCode() : 0);
		result = 31 * result + age;
		temp = Double.doubleToLongBits(salary);
		result = 31 * result + (int) (temp ^ (temp >>> 32));
		return result;
	}
}
~~~

- EmployeeData类

~~~java
package com.test.java2;

import java.util.ArrayList;
import java.util.List;
/**
 * 提供用于测试的数据
 * 
 * @author shkstart 邮箱：shkstart@126.com
 *
 */
public class EmployeeData {
	
	public static List<Employee> getEmployees(){
		List<Employee> list = new ArrayList<>();
		
		list.add(new Employee(1001, "马化腾", 34, 6000.38));
		list.add(new Employee(1002, "马云", 12, 9876.12));
		list.add(new Employee(1003, "刘强东", 33, 3000.82));
		list.add(new Employee(1004, "雷军", 26, 7657.37));
		list.add(new Employee(1005, "李彦宏", 65, 5555.32));
		list.add(new Employee(1006, "比尔盖茨", 42, 9500.43));
		list.add(new Employee(1007, "任正非", 26, 4333.32));
		list.add(new Employee(1008, "扎克伯格", 35, 2500.32));
		
		return list;
	}
}
~~~

- MethodRefTest类：方法引用的使用

~~~java
package com.test.java2;

import org.junit.Test;

import java.io.PrintStream;
import java.util.Comparator;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * 方法引用的使用
 *
 * 1、使用情境：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！
 *
 * 2、方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例，所以，方法引用，也是函数式接口的实例
 *
 * 3、使用格式：(类)对象 :: 方法名
 *
 * 4、具体分为如下的三种情况
 * 		情况一： 对象 :: 非静态方法
 * 		情况二： 类 :: 静态方法
 *
 * 		情况三： 类 :: 非静态方法
 *
 * 5、方法引用使用的要求：要求接口中的抽象方法的形参列表与和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况一和情况二）
 *
 * Created by shkstart.
 */
public class MethodRefTest {

	// 情况一：对象 :: 实例方法
	//Consumer中的void accept(T t)
	//PrintStream中的void println(T t)
	@Test
	public void test1() {
		Consumer<String> consumer = str -> System.out.println(str);
		consumer.accept("北京");

		System.out.println("********************************");

		// 方法引用
		PrintStream ps = System.out;
		Consumer<String> consumer1 = ps::println;
		consumer1.accept("beijing");

	}
	
	//Supplier中的T get()
	//Employee中的String getName()
	@Test
	public void test2() {
		Employee employee = new Employee(10, "TOM", 20, 5000);

		Supplier<String> sup = () -> employee.getName();
		System.out.println(sup.get());

		System.out.println("********************************");

		// 方法引用
		Supplier<String> sup1 = employee::getName;
		System.out.println(sup1.get());
	}

	// 情况二：类 :: 静态方法
	//Comparator中的int compare(T t1,T t2)
	//Integer中的int compare(T t1,T t2)
	@Test
	public void test3() {
		Comparator<Integer> com = (o1, o2) -> Integer.compare(o1, o2);
		System.out.println(com.compare(12,21));

		System.out.println("********************************");

		Comparator<Integer> com1 = Integer::compare;
		System.out.println(com1.compare(21, 12));
	}
	
	//Function中的R apply(T t)
	//Math中的Long round(Double d)
	@Test
	public void test4() {
		Function<Double, Long> fun = new Function<>() {
			@Override
			public Long apply(Double d) {
				return Math.round(d);
			}
		};

		Function<Double, Long> fun1 = d -> Math.round(d);
		System.out.println(fun1.apply(6.3));

		System.out.println("********************************");

		Function<Double, Long> fun2 = Math::round;
		System.out.println(fun2.apply(6.6));
	}

	// 情况三：类 :: 实例方法 
	// Comparator中的int comapre(T t1,T t2)
	// String中的int t1.compareTo(t2)
	@Test
	public void test5() {
		Comparator<String> com = (t1, t2) -> t1.compareTo(t2);
		System.out.println(com.compare("abc", "abd"));

		System.out.println("********************************");

		Comparator<String> com1 = String::compareTo;
		System.out.println(com1.compare("abc", "abd"));
	}

	//BiPredicate中的boolean test(T t1, T t2);
	//String中的boolean t1.equals(t2)
	@Test
	public void test6() {
		BiPredicate<String,String> bi = (s1, s2) -> s1.equals(s2);
		System.out.println(bi.test("abc", "abc"));

		System.out.println("********************************");

		BiPredicate<String,String> bi1 = String::equals;
		System.out.println(bi1.test("abc", "abd"));
	}
	
	// Function中的R apply(T t)
	// Employee中的String getName();
	@Test
	public void test7() {
		Employee employee = new Employee(1001, "Jack", 22, 6000);

		Function<Employee, String> fun1 = e -> e.getName();
		System.out.println(fun1.apply(employee));

		System.out.println("********************************");

		Function<Employee, String> fun2 = Employee::getName;
		System.out.println(fun2.apply(employee));
	}
}
~~~

- ConstructorRefTest类：构造器引用的使用

~~~java
package com.test.java2;

import org.junit.Test;

import java.util.Arrays;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * 一、构造器引用
 *      和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。
 *      抽象方法的返回值类型即为构造器所属的类的类型
 *
 * 二、数组引用
 *      可以把数组看做是一个特殊的类，则写法与构造器引用一致。
 *
 * Created by shkstart
 */
public class ConstructorRefTest {
	//构造器引用
    //Supplier中的T get()
    // Employee的空参构造器：Employee()
    @Test
    public void test1(){
        Supplier<Employee> sup = new Supplier<Employee>() {
            @Override
            public Employee get() {
                return new Employee();
            }
        };
        System.out.println(sup.get());

        System.out.println("*****************************");

        Supplier<Employee> sup1 = () -> new Employee();
        System.out.println(sup1.get());

        System.out.println("*****************************");

        Supplier<Employee> sup2 = Employee::new;
        System.out.println(sup2.get());
	}

	//Function中的R apply(T t)
    @Test
    public void test2(){
        Function<Integer, Employee> fun = id -> new Employee(id);
        Employee employee = fun.apply(1001);
        System.out.println(employee);

        System.out.println("*****************************");

        Function<Integer, Employee> fun1 = Employee::new;
        Employee employee1 = fun1.apply(1002);
        System.out.println(employee1);
    }

	//BiFunction中的R apply(T t,U u)
    @Test
    public void test3(){
        BiFunction<Integer, String, Employee> fun1 = (id, name) -> new Employee(id, name);
        System.out.println(fun1.apply(1001, "TOM"));

        System.out.println("*****************************");

        BiFunction<Integer, String, Employee> fun2 = Employee::new;
        System.out.println(fun2.apply(1002, "Jack"));
	}

	//数组引用
    //Function中的R apply(T t)
    @Test
    public void test4(){
        Function<Integer, String[]> fun  = length -> new String[length];
        String[] apply = fun.apply(5);
        System.out.println(Arrays.toString(apply));

        System.out.println("*****************************");

        Function<Integer, String[]> fun1 = String[]::new;
        String[] apply1 = fun1.apply(10);
        System.out.println(Arrays.toString(apply1));
    }
}
~~~

#### Stream API

- 概述

  1. Stream关注的是对数据的运算，与CPU打交道；集合关注的是数据的存储，与内存打交道

  2. > Stream 自己不会存储元素
     >
     > Stream 不会改变源对象，相反，它们会返回一个持有结果的新Stream。
     >
     > Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行

  3. Stream 执行流程

     > Stream的实例化
     >
     > 一系列的中间操作（过滤、映射、...）
     >
     > 终止操作

  4. 终止操作

     > 一个中间操作链，对数据源的数据进行处理
     >
     > 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用

- Stream的实例化

~~~java
 // 创建 Stream 方式一：通过集合
@Test
public void test1() {
  List<Employee> employees = EmployeeData.getEmployees();

  // default Stream<E> stream()：返回一个顺序流
  Stream<Employee> stream = employees.stream();

  // default Stream<E> parallelStream(): 返回一个并行流
  Stream<Employee> employeeStream = employees.parallelStream();
}

// 创建 Stream 方式二：通过数组
@Test
public void test2() {
  int[] arr = new int[]{1,2,3,4,5,6};
  // 调用Arrays类的static <T> Stream<T> stream(T[] array)：返回一个流
  IntStream stream = Arrays.stream(arr);

  Employee e1 = new Employee(1001, "Tom");
  Employee e2 = new Employee(1002, "Jack");
  Employee[] arr1 = new Employee[]{e1, e2};
  Stream<Employee> stream1 = Arrays.stream(arr1);
}

// 创建 Stream 方式三：通过  Stream 的 of()
@Test
public void test3() {
  Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6);
}

// 创建 Stream 方式四：创建无限流
@Test
public void test4() {
  /*
  迭代
  public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)
  遍历10个偶数
  */
  Stream.iterate(0, t -> t + 2).limit(10).forEach(System.out::println);

  /*
  生成
  public static<T> Stream<T> generate(Supplier<T> s)
  */
  Stream.generate(Math::random).limit(10).forEach(System.out::println);
}
~~~

- Stream的中间操作

  - 筛选与切片

  ~~~java
  @Test
  public void test1() {
    List<Employee> list = EmployeeData.getEmployees();
    // filter(Predicate p)---接收Lambda，从流中排除某些元素
    Stream<Employee> stream = list.stream();
    // 练习：查询员工表中薪资大于7000的员工信息
    stream.filter(e -> e.getSalary() > 7000).forEach(System.out::println);
  
    System.out.println();
    // limit(n)---截断流，使其元素不超过给定数量。
    list.stream().limit(3).forEach(System.out::println);
  
    System.out.println();
    // skip(n)---跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补
    list.stream().skip(3).forEach(System.out::println);
  
    System.out.println();
    // distinct()---筛选，通过流所生成元素的hashCode() 和 equals() 去除重复元素
    list.add(new Employee(1010, "马云", 50, 6000));
    list.add(new Employee(1010, "马云", 51, 6000));
    list.add(new Employee(1010, "马云", 50, 6000));
    list.add(new Employee(1010, "马云", 50, 6000));
  
    list.stream().distinct().forEach(System.out::println);
  }
  ~~~

  - 映射

  ~~~java
  @Test
  public void test2() {
    // map(Function f)--接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射称一个新的元素。
    List<String> list = Arrays.asList("aa", "bb", "cc");
    list.stream().map(str -> str.toUpperCase()).forEach(System.out::println);
  
    // 练习：获取员工姓名长度大于3的员工的姓名
    EmployeeData.getEmployees().stream().map(Employee::getName).filter(name -> name.length() > 3).forEach(System.out::println);
  
    System.out.println();
  
    // 练习2：
    Stream<Stream<Character>> streamStream = list.stream().map(StreamAPITest1::fromStringToStream);
    streamStream.forEach(s->{
      s.forEach(System.out::println);
    });
  
    System.out.println();
  
    // flatMap(Function f)--接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。
    list.stream().flatMap(StreamAPITest1::fromStringToStream).forEach(System.out::println);
  
  
  }
  
  // 将字符串中的多个字符构成的集合转换为对应的Stream的实例
  public static Stream<Character> fromStringToStream(String str) {
    ArrayList<Character> list = new ArrayList<>();
    for (Character c : str.toCharArray()) {
      list.add(c);
    }
    return list.stream();
  }
  ~~~

  - 排序

  ~~~java
  @Test
  public void test3() {
    // sorted() -- 自然排序
    List<Integer> list = Arrays.asList(8, 4, 5, 7, 13, -5, 0, 6);
    list.stream().sorted().forEach(System.out::println);
  
    // 抛异常， 原因：Employee类没有实现comparable接口
    //        List<Employee> employees = EmployeeData.getEmployees();
    //        employees.stream().sorted().forEach(System.out::println);
  
    // sorted(Comparator com) -- 定制排序
    List<Employee> employees = EmployeeData.getEmployees();
    employees.stream().sorted( (e1, e2) -> {
      int i = Integer.compare(e1.getAge(), e2.getAge());
      if (i != 0) {
        return  i;
      } else {
        return Double.compare(e1.getSalary(), e2.getSalary());
      }
  
    }).forEach(System.out::println);
  }
  ~~~

- Stream的终止操作

  - 匹配与查找

  ~~~java
  @Test
  public void test1() {
      List<Employee> list = EmployeeData.getEmployees();
  
      /*
       allMatch(Predicate p) 检查是否匹配所有元素
       练习：是否所有的员工的年龄都大于18
       */
      boolean allMatch = list.stream().allMatch(e -> e.getAge() > 18);
      System.out.println(allMatch);
  
      /*
      anyMatch(Predicate p) 检查是否至少匹配一个元素
      练习：是否存在员工的工资大于10000
       */
      boolean anyMatch = list.stream().anyMatch(e -> e.getSalary() > 10000);
      System.out.println(anyMatch);
  
      /*
      noneMatch(Predicate p) 检查是否没有匹配所有元素
      练习：是否存在员工姓“雷”
       */
      boolean noneMatch = list.stream().noneMatch(e -> e.getName().startsWith("雷"));
      System.out.println(noneMatch);
  
      /*
      findFirst() 返回第一个元素
       */
      Optional<Employee> first = list.stream().findFirst();
      System.out.println(first);
  
      /*
       findAny() 返回当前流中的任意元素
       */
      Optional<Employee> any = list.parallelStream().findAny();
      System.out.println(any);
  
      /*
       count() 返回流中元素总数
       */
      long count = list.stream().count();
      System.out.println(count);
  
      /*
       max(Comparator c) 返回流中最大值
       练习：返回最高的工资。
       */
      Optional<Double> max = list.stream().map(e -> e.getSalary()).max(Double::compare);
      System.out.println(max);
  
       /*
       min(Comparator c) 返回流中最小值
       练习：返回最低工资的员工。
       */
      Optional<Employee> min = list.stream().min((e1, e2) -> Double.compare(e1.getSalary(), e2.getSalary()));
      System.out.println(min);
  
      // forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。相反，Stream API 使用内部迭代——它帮你把迭代做了)
      list.stream().forEach(System.out::println);
  
      // 使用集合的遍历操作
      list.forEach(System.out::println);
  }
  ~~~

  - 归约

  ~~~java
  @Test
  public void test1() {
    //     reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 T
    List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6);
    Integer sum = list.stream().reduce(0, Integer::sum);
    System.out.println(sum);
  
    //     reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 Optional<T>
    List<Employee> employees = EmployeeData.getEmployees();
    Stream<Double> doubleStream = employees.stream().map(Employee::getSalary);
    Optional<Double> sumMoney = doubleStream.reduce((d1, d2) -> d1 + d2);
    System.out.println(sumMoney);
  }
  ~~~

  - 收集

  ~~~java
   @Test
  public void test2() {
    // collect(Collector c) 将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法
    // 练习：查找工资大于6000的员工，结果返回为一个List或Set
  
    List<Employee> employees = EmployeeData.getEmployees();
    List<Employee> list = employees.stream().filter(e -> e.getSalary() > 6000).collect(Collectors.toList());
    list.forEach(System.out::println);
  
    System.out.println();
  
    Set<Employee> set = employees.stream().filter(e -> e.getSalary() > 6000).collect(Collectors.toSet());
    set.forEach(System.out::println);
  }
  ~~~

### Java9新特性

#### JDK和JRE目录结构的改变

> jdk 9 以上没有名为jre的子目录

#### 模块化系统

> 本质上讲也就是说，用模块来管理各个package，通过声明某个package 暴露，，模块(module)的概念，其实就是package外再裹一层，不声明默 认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪 些部分可以暴露，哪些部分隐藏。

- 实现目标

> 1. 模块化的主要目的在于减少内存的开销 
> 2. 只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的开 发和维护 
> 3. 改进 Java SE 平台，使其可以适应不同大小的计算设备 
> 4. 改进其安全性，可维护性，提高性能

- 目录结构

~~~java
day13
  - src
  - - com.test.java
  - - - ModuleTest.java
  - - module-info.java
  
java9Test
  - src
  - - com.java.bean
  - - - Person.java
  - - module-info.java
~~~



- day13模块下

  - ModuleTest.java

    ~~~java
    package com.test.java;
    
    import com.java.bean.Person;
    
    /**
     * @author: my.seaTide
     * @create: 2021/6/6 1:54 下午
     */
    public class ModuleTest {
    
        public static void main(String[] args) {
            Person person = new Person("Tom", 23);
            System.out.println(person);
        }
    }
    ~~~

  - module-info.java

    ~~~java
    /**
     * @author: my.seaTide
     * @create: 2021/6/6 1:51 下午
     */
    module day13 {
        requires java9Test;
    }
    ~~~

- java9Test模块下

  - Person.java

    ~~~java
    package com.java.bean;
    
    /**
     * @author: my.seaTide
     * @create: 2021/6/6 1:52 下午
     */
    public class Person {
    
        private String name;
        private int age;
    
        public Person() {
        }
    
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public int getAge() {
            return age;
        }
    
        public void setAge(int age) {
            this.age = age;
        }
    
        @Override
        public String toString() {
            return "Person{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    '}';
        }
    }
    ~~~

  - module-info.java

    ~~~java
    /**
     * @author: my.seaTide
     * @create: 2021/6/6 1:51 下午
     */
    module java9Test {
        exports com.java.bean;
    }
    ~~~

#### Java的REPL工具：jShell命令

> 1. jShell 调出Jshell
> 2. /help intro 获取帮助
> 3. System.out.println<"你好！world">; int i = 10; 基本使用
> 4. import java.util.*;  导入指定的包
> 5. /list 列出当前 session 里所有有效的代码片段
> 6. /vars 查看当前 session 下所有创建过的变量  注意：我们还可以重新定义相同方法名和参 数列表的方法，即为对现有方法的修改（或 覆盖）。
> 7. /methods 查看当前 session 下所有创建过的方法
> 8. /open 文件地址； 使用/open命令调用

注意：在 JShell 环境下，语句末尾的“;” 是可 选的。但推荐还是最好加上。提高代码可读 性。

#### 接口中声明私有方法

- MyInterface

~~~java
package com.test.java;

/**
 * @author: my.seaTide
 * @create: 2021/6/6 3:05 下午
 */
public interface MyInterface {

    // 如下的三个方法的权限修饰符都是public
    void methodAbstract();

    static void methodStatic() {
        System.out.println("接口中的静态方法");
    }

    default void methodDefault() {
        System.out.println("接口中的默认方法");

        methodPrivate();
    }

    // jdk 9 中允许接口中定义私有的方法
    private void methodPrivate() {
        System.out.println("接口中的私有方法");
    }
}
~~~

- 实现类：MyInterfaceImp

~~~java
package com.test.java;

/**
 * @author: my.seaTide
 * @create: 2021/6/6 3:07 下午
 */
public class MyInterfaceImp implements MyInterface{
    @Override
    public void methodAbstract() {

    }

    @Override
    public void methodDefault() {
        System.out.println("实现类中重写接口中的默认方法");
    }

    public static void main(String[] args) {
        // 接口中的静态方法只能由接口自己调用
        MyInterface.methodStatic();

        // 接口的实现类不能调用接口中的静态方法
//        MyInterfaceImp.methodStatic();

        MyInterfaceImp myInterfaceImp = new MyInterfaceImp();
        myInterfaceImp.methodDefault();

        // 接口的私有方法，不能在接口外部调用
//        myInterfaceImp.methodPrivate();
    }
}
~~~

#### 钻石操作符的语法升级

~~~java
@Test
public void test1() {
  // 钻石操作符<>与匿名内部类在java 8中不能共存。在java中可以
  Comparator<Object> com = new Comparator<>() {
    @Override
    public int compare(Object o1, Object o2) {
      return 0;
    }
  };

  // jdk 7中的新特性：类型推断
  ArrayList<Object> list = new ArrayList<>();
}
~~~

#### try结构的语法升级

- 基本写法

~~~java
public static void main(String[] args) {  
  InputStreamReader isr = null;
    try {
      isr = new InputStreamReader(System.in);

      char[] cbuf = new char[20];
      int len;
      if ((len = isr.read(cbuf)) != -1) {
        String s = new String(cbuf, 0, len);
        System.out.println(s);
      }
    } catch (IOException e) {
      e.printStackTrace();
    } finally {
      try {
        isr.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
}
~~~

- Java 8中资源关闭操作

~~~java
public static void main(String[] args) {
  
 // Java8中资源关闭操作：Java 8 中可以实现资源的自动关闭，
 // 但是要求执行后必须关闭的所有资源必须在try子句中初始化，否则编译不通过
  try(InputStreamReader isr = new InputStreamReader(System.in)) {
    char[] cbuf = new char[20];
    int len;
    if ((len = isr.read(cbuf)) != -1) {
      String s = new String(cbuf, 0, len);
      System.out.println(s);
    }
  } catch (IOException e) {
    e.printStackTrace();
  }
}
~~~

- Java 9中资源关闭操作

~~~java
public static void main(String[] args) {
  // Java 9中资源关闭操作：需要自动关闭的资源的实例化可以放在try的一堆小括号外。
  // 此时的资源属性是常量，声明为final的，不可修改
  InputStreamReader isr = new InputStreamReader(System.in);
  try (isr) {
    char[] cbuf = new char[20];
    int len;
    if ((len = isr.read(cbuf)) != -1) {
      String s = new String(cbuf, 0, len);
      System.out.println(s);
    }
  } catch (IOException e) {
    e.printStackTrace();
  }
}
~~~

#### String底层存储结构的变更

> String由原来的char[]存储改成了byte[] 加上编码标记。节约空间

- StringBuffer 和 StringBuilder

> 由原来的char[]存储改成了byte[] 加上编码标记。节约空间

#### 集合工厂方法：快速创建只读集合

> 要创建一个只读、不可改变的集合，必须构造和分配它，然后添加元素，最后 包装成一个不可修改的集合。

- Java 8中的写法

~~~java
@Test
public void test1() {
  List<String> namesList = new ArrayList<>();
  namesList.add("Joe");
  namesList.add("Bob");
  namesList.add("Bill");
  // 返回的namesList是一个只读的集合
  namesList = Collections.unmodifiableList(namesList);

  //        namesList.add("Tom");
  System.out.println(namesList);
}

@Test
public void test2() {
  List<String> list = Collections.unmodifiableList(Arrays.asList("a", "b", "c"));
  Set<String> set = Collections.unmodifiableSet(new HashSet<>(Arrays.asList("a","b", "c")));
  // 如下操作不适用于jdk 8 及之前版本,适用于jdk 9
  Map<String, Integer> map = Collections.unmodifiableMap(new HashMap<>() {
    {
      put("a", 1);
      put("b", 2);
      put("c", 3);
    }
  });
  map.forEach((k, v) -> System.out.println(k + ":" + v));
}

@Test
public void test3() {
  // 此时得到的集合list也是一个只读集合
  List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6);

  // 报异常：UnsupportedOperationException
  list.add(7);
}
~~~

- Java 9中的写法

~~~java
@Test
public void test4() {
  List<Integer> list = List.of(1, 2, 3, 4, 5, 6);
  // 不能添加
  //        list.add(7);
  System.out.println(list);

  Set<Integer> set = Set.of(23, 45, 67, 89, 34, 56);
  // 不能添加
  //        list.add(7);
  System.out.println(set);

  Map<String, Integer> map = Map.of("Jack", 24, "Tom", 30);
  // 不能添加
  //        map.put("Jetty", 50);
  System.out.println(map);

  Map<String, Integer> entries = Map.ofEntries(Map.entry("Tom", 23), Map.entry("zhangsan", 49));
  // 不能添加
  //        entries.put("lisi", 60);
  System.out.println(entries);
}
~~~

#### InputStream加强

> InputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接 传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下 示例。

~~~java
ClassLoader cl = this.getClass().getClassLoader();
try (InputStream is = cl.getResourceAsStream("hello.txt");
    OutputStream os = new FileOutputStream("src\\hello1.txt")) {
    is.transferTo(os); // 把输入流中的所有数据直接自动地复制到输出流中
} catch (IOException e) {
		e.printStackTrace();
}
~~~

#### 增强的Stream API

1. Java 的 Steam API 是java标准库最好的改进之一，让开发者能够快速运算， 从而能够有效的利用数据并行计算。Java 8 提供的 Steam 能够利用多核架构 实现声明式的数据处理。
2. 在 Java 9 中，Stream API 变得更好，Stream 接口中添加了 4 个新的方法： takeWhile, dropWhile, ofNullable，还有个 iterate 方法的新重载方法，可以 让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。
3. 除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。 现在可以通过 Optional 的新方法 stream() 将一个 Optional 对象转换为一个 (可能是空的) Stream 对象。

- takeWhile()的使用

> 用于从 Stream 中获取一部分数据，接收一个 Predicate 来进行选择。在有序的 Stream 中，takeWhile 返回从开头开始的尽量多的元素。

~~~java
@Test
public void test1() {
  List<Integer> list = Arrays.asList(1, 2, 3, 56, 78, 37, 89, 75, 67, 98, 23);

  // takeWhile 返回从开头开始的按照指定规则尽量多的元素
  list.stream().takeWhile(x -> x < 60).forEach(System.out::println);
}
~~~

- dropWhile()的使用

> dropWhile 的行为与 takeWhile 相反，返回剩余的元素。

~~~java
@Test
public void test1() {
  List<Integer> list = Arrays.asList(1, 2, 3, 56, 78, 37, 89, 75, 67, 98, 23);

  // dropWhile()：与takeWhile() 相反，返回剩余的元素。
  list.stream().dropWhile(x -> x < 60).forEach(System.out::println);
}
~~~

- ofNullable()的使用

> Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方 法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。

~~~java
@Test
public void test2() {
  // of() 参数中的多个元素，可以包含null值
  Stream<Integer> stream = Stream.of(1, 2, 3, null);
  stream.forEach(System.out::println);

  // of() 参数不能存储单个null值。否则，报异常
  //        Stream<Object> stream1 = Stream.of(null);
  //        System.out.println(stream1);

  Integer i = 10;
  i= null;
  // ofNullable()：形参变量是可以为null值的单个元素
  Stream<Integer> stream2 = Stream.ofNullable(i);
  System.out.println(stream2.count());
}
~~~

- iterate()重载的使用

> 这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什 么时候结束迭代。

~~~java
@Test
public void test3() {
  // Java 8中的写法
  Stream.iterate(0, x -> x + 1).limit(10).forEach(System.out::println);

  // Java 9中新增的重载的方法
  Stream.iterate(0, x -> x < 100, x -> x + 1).forEach(System.out::println);
}
~~~

#### Optional获取Stream的方法

- Optional类中stream()的使用

~~~java
List<String> list = new ArrayList<>();
list.add("Tom");
list.add("Jerry");
list.add("Tim");
Optional<List<String>> optional = Optional.ofNullable(list);
Stream<List<String>> stream = optional.stream();
stream.flatMap(x -> x.stream()).forEach(System.out::println);
~~~

#### Javascript引擎升级：Nashorn

1. Nashorn 项目在 JDK 9 中得到改进，它为 Java 提供轻量级的 Javascript 运行时。 Nashorn 项目跟随 Netscape 的 Rhino 项目，目的是为了在 Java 中实现一个高 性能但轻量级的 Javascript 运行时。Nashorn 项目使得 Java 应用能够嵌入 Javascript。它在 JDK 8 中为 Java 提供一个 Javascript 引擎。
2. JDK 9 包含一个用来解析 Nashorn 的 ECMAScript 语法树的 API。这个 API 使得 IDE 和服务端框架不需要依赖 Nashorn 项目的内部实现类，就能够分析 ECMAScript 代码。



### Java 10 新特性

#### 局部变量类型推断
- 工作原理
> 在处理 var时，编译器先是查看表达式右边部分，并根据右边变量值的类型进行
> 推断，作为左边变量的类型，然后将该类型写入字节码当中。

- 注 意
    - var不是一个关键字
    > 你不需要担心变量名或方法名会与 var发生冲突，因为 var实际上并不是一个关键字，
> 而是一个类型名，只有在编译器需要知道类型的地方才需要用到它。除此之外，它
> 就是一个普通合法的标识符。也就是说，除了不能用它作为类名，其他的都可以，
> 但极少人会用它作为类名。
    
    - 这不是JavaScript
    > 首先我要说明的是，var并不会改变Java是一门静态类型语言的事实。编译器负责推
> 断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。
> 下面是使用 IntelliJ（实际上是 Fernflower的反编译器）反编译器反编译出的代码：
    
    ~~~java
    @Test
    public void test4() {
        try {
            var url = new URL("http://www.atguigu.com");
            var connection = url.openConnection();
            var reader = new BufferedReader(
                    new InputStreamReader(connection.getInputStream()));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    反编译后：
    
    URL url = new URL("http://www.atguigu.com");
    URLConnection connection = url.openConnection();
    BufferedReader reader = new BufferedReader(
    new InputStreamReader(connection.getInputStream()));
    ~~~

- 局部变量的类型推断的使用
~~~java
package com.test.java;

import org.junit.Test;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.ArrayList;
import java.util.function.Consumer;
import java.util.function.Supplier;

public class Java10Test {

    /*
    局部变量的类型推断
     */
    @Test
    public void test1() {
        // 1、声明变量时，根据所附的值，推断变量的类型
        var num = 10;

        var list = new ArrayList<Integer>();
        list.add(123);

        // 2、遍历操作
        for (var i : list) {
            System.out.println(i.getClass());
        }

        // 3.普通的遍历操作
        for (var i = 0; i < 100; i++) {
            System.out.println(i);
        }
    }

    /*
    在局部变量中使用时，如下情况不适用：
     */
    @Test
    public void test2() {
        // 1、局部变量不赋值，就不能实现类型推断
//        var num;

        // 2、Lambda表达式中，左边的函数式接口不能声明为var
        Supplier<Double> sup = () -> Math.random();
        // sup = () ->Math.random(); 错误的

        // 3、方法引用中，左边的函数式接口不能声明为var
        Consumer<String> con = System.out::println;
//        var con = System.out::println; 错误的

        // 4、数组的静态初始化中，注意如下的情况也不可以
        int[] arr = {1, 2, 3, 4};
//        var arr = {1, 2, 3, 4};// 错误的
    }

    /*
    也不适用于以下情况
     */
    @Test
    public void test3() {
//      情况1：没有初始化的局部变量声明
//        var num = null;
//        var num;

//        情况6：catch块
//        try {
//
//        } catch (var e) {
//
//        }
    }

//    情况2：方法的返回类型
//    public var method() {
//        return 0;
//    }

//    情况3：方法的参数类型
//    public void method1(var num) {}

//    情况4：构造器的参数类型
//    public Java10Test(var i){};

//    情况5：属性
//    var num = 10;
}
~~~

#### 集合新增创建不可变集合的方法

> 自 Java 9 开始，Jdk 里面为集合（List / Set / Map）都添加了 of (jdk9新增)和
> copyOf (jdk10新增)方法，它们两个都用来创建不可变的集合，来看下它们的
> 使用和区别。

~~~java
@Test
public void test5() {
    //示例1：
    var list1 = List.of("Java", "Python", "C");
    var copy1 = List.copyOf(list1);
    System.out.println(list1 == copy1); // true
    //示例2：
    var list2 = new ArrayList<String>();
    var copy2 = List.copyOf(list2);
    System.out.println(list2 == copy2); // false
    // 示例1和2代码基本一致，为什么一个为true,一个为false?
    // 结论：copyOf(Xxx coll)：如果参数coll本身就是一个只读集合，则copyOf()返回值即为当前的coll
    // 如果参数coll不是一个只读集合，则copyOf()返回一个新的集合，这个集合是只读的。
}
~~~

> 从 源 码 分 析 ， 可 以 看 出 copyOf 方 法 会 先 判 断 来 源 集 合 是 不 是
> AbstractImmutableList 类型的，如果是，就直接返回，如果不是，则调用 of 创
> 建一个新的集合。
> 示例2因为用的 new 创建的集合，不属于不可变 AbstractImmutableList 类的子类，
> 所以 copyOf 方法又创建了一个新的实例，所以为false。
> 注意：使用of和copyOf创建的集合为不可变集合，不能进行添加、删除、替换、
> 排序等操作，不然会报 java.lang.UnsupportedOperationException 异常。
> 上面演示了 List 的 of 和 copyOf 方法，Set 和 Map 接口都有。


### Java 11新特性
#### String新增了一系列字符串处理方法
~~~java
@Test
public void test1() {
    // isBlank():判断字符串是否为空白
    System.out.println("  ".isBlank()); // true
    System.out.println(" \t \t \n ".isBlank()); // true

    // strip():去除首尾空白
    System.out.println("----" + "  \t 123 \t \n ".strip() + "----"); // ----123----
    System.out.println("----" + "  \t 123 \t \n ".trim() + "----"); // ----123----

    // stripTrailing():去除尾部空格
    System.out.println("----" + "  \t 123 \t \n ".stripTrailing() + "----"); // ----  	 123----

    // stripLeading():去除首部空格
    System.out.println("----" + "  \t 123 \t ".stripLeading() + "----");// ----123   ----

    // repeat(int count):复制字符串
    String str = "abc";
    System.out.println(str.repeat(3)); // abcabcabc

    // lines().count():行数统计
    String str1 = "abcdefg\nhigkl\nmnopq";
    System.out.println(str1.lines().count());// 3
}
~~~

#### Optional 加强
> Optional 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换
> 成一个 Stream, 或者当一个空 Optional 时给它一个替代的。

~~~java
@Test
public void test2() {
    var op = Optional.empty();

    // isEmpty():判断value是否为空
    System.out.println(op.isPresent()); // 判断内部的value是否存在
    System.out.println(op.isEmpty()); // 判断内部的value是否为空

    // orElseThrow():value非空，返回value；否则抛异常NoSuchElementException
    op = Optional.of("abc");
    var obj = op.orElseThrow();
    System.out.println(obj);

    // or:value非空，返回对应的Optional；value为空，返回形参封装的Optional
    var op1 = Optional.of("hello");
//        op = Optional.empty();
    Optional<Object> op2 = op.or(() -> op1);
    System.out.println(op2);
}
~~~

#### 局部变量类型推断升级
> 在var上添加注解的语法格式，在jdk10中是不能实现的。在JDK11中加入了这样
> 的语法。

~~~java
//错误的形式: 必须要有类型, 可以加上var
//Consumer<String> con1 = (@Deprecated t) ->
System.out.println(t.toUpperCase());
//正确的形式:
//使用var的好处是在使用lambda表达式时给参数加上注解。
Consumer<String> con2 = (@Deprecated var t) ->
System.out.println(t.toUpperCase());
~~~

#### 全新的HTTP 客户端
1. HTTP，用于传输网页的协议，早在1997年就被采用在目前的1.1版本中。直
到2015年，HTTP2才成为标准。
2. HTTP/1.1和HTTP/2的主要区别是如何在客户端和服务器之间构建和传输数据。
HTTP/1.1依赖于请求/响应周期。 HTTP/2允许服务器“push”数据：它可以发
送比客户端请求更多的数据。这使得它可以优先处理并发送对于首先加载
网页至关重要的数据。
3. 这是 Java 9 开始引入的一个处理 HTTP 请求的的 HTTP Client API，该
API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在
java.net 包中找到这个 API。
4. 它 将 替 代 仅 适 用 于 blocking 模式的 HttpURLConnection
（HttpURLConnection是在HTTP 1.0的时代创建的，并使用了协议无关的
方法），并提供对WebSocket 和 HTTP/2的支持。

~~~java
HttpClient client = HttpClient.newHttpClient();
HttpRequest request =
HttpRequest.newBuilder(URI.create("http://127.0.0.1:8080/test/")).build();
BodyHandler<String> responseBodyHandler = BodyHandlers.ofString();
HttpResponse<String> response = client.send(request, responseBodyHandler);
String body = response.body();
System.out.println(body);
~~~

~~~java
HttpClient client = HttpClient.newHttpClient();
HttpRequest request =
HttpRequest.newBuilder(URI.create("http://127.0.0.1:8080/test/")).build();
BodyHandler<String> responseBodyHandler = BodyHandlers.ofString();
CompletableFuture<HttpResponse<String>> sendAsync =
client.sendAsync(request, responseBodyHandler);
sendAsync.thenApply(t -> t.body()).thenAccept(System.out::println);
//HttpResponse<String> response = sendAsync.get();
//String body = response.body();
//System.out.println(body);
~~~

#### 更简化的编译运行程序
~~~java
// 编译
javac Javastack.java
// 运行
java Javastack

在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。
而在未来的 Java 11 版本中，通过一个 java 命令就直接搞定了，如以下所示：
java Javastack.java

一个命令编译运行源代码的注意点：
1. 执行源文件中的第一个类, 第一个类必须包含主方法。
2. 并且不可以使用其它源文件中的自定义类, 本文件中的自定义类是可以使用的。
~~~

#### 废弃Nashorn引擎
> 废除Nashorn javascript引擎，在后续版本准备移除掉，有需要的
> 可以考虑使用GraalVM。

#### ZGC
1. GC是java主要优势之一。 然而, 当GC停顿太长, 就会开始影响应用的响应时
间。消除或者减少GC停顿时长, java将对更广泛的应用场景是一个更有吸引力
的平台。此外, 现代系统中可用内存不断增长,用户和程序员希望JVM能够以高
效的方式充分利用这些内存, 并且无需长时间的GC暂停时间。

2. ZGC, A Scalable Low-Latency Garbage Collector(Experimental)
ZGC, 这应该是JDK11最为瞩目的特性, 没有之一。 但是后面带了Experimental,
说明这还不建议用到生产环境。

3. ZGC是一个并发, 基于region, 压缩型的垃圾收集器, 只有root扫描阶段会
STW(stop the world), 因此GC停顿时间不会随着堆的增长和存活对象的增长
而变长。

4. 优势：

> 1. GC暂停时间不会超过10ms
> 2. 既能处理几百兆的小堆, 也能处理几个T的大堆(OMG)\
> 3. 和G1相比, 应用吞吐能力不会下降超过15%
> 4. 为未来的GC功能和利用colord指针以及Load barriers优化奠定基础
> 5. 初始只支持64位系统

5. ZGC的设计目标是：支持TB级内存容量，暂停时间低（<10ms），对整个
程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人
兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），
或压缩堆。

#### 其他新特性

>1. Unicode 10
>2. Deprecate the Pack200 Tools and API
>3. 新的Epsilon垃圾收集器
>4. 完全支持Linux容器（包括Docker）
>5. 支持G1上的并行完全垃圾收集
>6. 最新的HTTPS安全协议TLS 1.3
>7. Java Flight Recorder